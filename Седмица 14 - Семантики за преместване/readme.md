# Седмица 14 - Семантики за преместване

## Видове стойности в C++
В C++, всеки израз се характеризира по 2 начина - спрямо типа на израза и спрямо вида на стойността на израза. До сега сме говорили само за 2 вида стойности - `lvalue` и `rvalue`, но се оказва, че това не е най-правилното разделение на типовете стойности и затова сега ще разгледаме в детайли всички видове:
- `prvalue` (pure rvalue) - това са литералите (без низовете), ламбда функциите и резултатите от функции или оператори, чиито тип не е референция към друг обект (т.е. когато връщаме копия);
- `lvalue` - това са всички "именовани" обекти (променливи, функции, член-данни), низовите литерали и резултатите от функции или оператори, чиито тип е референция към друго `lvalue`;
- `xvalue` (eXpiring value) - това са временни обекти, чиито ресурси могат да бъдат преизползвани (преместени). Такива обекти получаваме, когато резултата на израза е т.нар. `rvalue reference` или когато резултата е `prvalue`, който обаче се каства към `rvalue reference`. `Rvalue reference` е референция към `rvalue`, която удължава живота на `rvalue` обекта, към който сочи, докато самата референция не бъде унищожена. Това означава, че временните обекти също имат място в паметта, което може да се достъпи чрез тези `rvalue references`;
- `glvalue` (generalized lvalue) - `lvalue` или `xvalue`;
- `rvalue` - `prvalue` или `xvalue`;

Новото, с което се сблъскваме в горния списък, са `xvalue` стойностите и в частност - `rvalue references`. За да декларираме `rvalue reference` трябва да използваме `&&` в декларацията на типа. Също така можем да използваме `std::move`, за да превърнем `lvalue` в `xvalue`. Ето няколко примера за създаване на `rvalue references`:

```c++
void foo(int&& a) {
  std::cout << a << '\n';
}

int bar() {
  return 7;
}

int main() {
  int&& a = 5;
  int b = 9;
  constexpr int c = 7;
  int&& d = b; // compile-time error, b has name => it is an lvalue
  int&& e = a; // compile-time error, a has name => it is an lvalue

  foo(3); // 3
  foo(bar()); // 7
  foo(b); // compile-time error, b has name => it is an lvalue
  foo(std::move(b)); // 5
  foo(a); // compile-time error, a has name => it is an lvalue
  foo(c); // compile-time error, rvalue references imply modifying the variable, but constexpr can't be modified
  foo(std::move(c)); // compile-time error, rvalue references imply modifying the variable, but constexpr can't be modified
  
  return 0;
}
```

## Семантики за преместване (move semantics)
`rvalue references`, подобно на `lvalue references`, ни позволяват да си спестим копиранията в част от случаите когато подаваме стойности като аргументи. `rvalue references` индикират, че сочената от тях стойност може да бъде "преместена", понеже скоро ще бъде унищожена. Това преместване се обосновава на специални правила, които се наричат семантики за преместване (move semantics). Според тях, когато една функция получава като аргумент rvalue reference, стойността сочена от референцията няма да бъде копирана, но функцията може да промени (или "открадне") стойността като обаче гарантира, че тя ще продължи да бъде валидна (т.е. инвариантата за типа на тази стойност ще продължи да бъде изпълнена). Именно заради това rvalue references сочат временни обекти или обекти, които скоро ще бъдат унищожени - чрез семантиките за преместване ние можем да преизполваме техните ресурси, вместо да ги копираме излишно. 

## Rule of 0-3-5
Вече се запознахме с rule of 0-3 или т.нар. голяма четворка. С помощта на семантиките за преместване обаче, ние можем да разширим този идиом до rule of 0-3-**5**. Двата допълнителни специални методи, които трябва да реализират нашите класове, за да спазват това правило, са  конструктор за преместване (move constructor) и оператор за преместване (move  assignment operator). Те имат следната сигнатура:

```c++
class A {
  A(A&& other) noexcept;
  A& operator=(A&& other) noexcept;
};
```

Отново, както и за останалите методи от голямата четворка, ако не дефинираме изрично конструктор за преместване и оператор за преместване, ще се създадат системни такива, които просто ще преместват директно член-данните. Тези два нови метода се използват, когато искаме нашият обект да "открадне" съдържанието на друг обект от същия клас, като не гарантира, че ще запази данните в оригиналния обект, но гарантира, че ще го остави във валидно състояние. Отново, правилото е, че ако ни се наложи да дефинираме изрично кой да е от следните 5 специални метода - конструктор за копиране, конструктор за преместване, оператор за копиране, оператор за преместване и деструктор, то трябва изрично да дефинираме всичките 5. Тук обаче има доста случаи, в които се налага да нарушим това правило - типичен пример са класове, представляващи обекти, които не могат да се копират, но техните данни могат да се "крадат" (това са например нишки, умни указатели и др.).

## Кога да ползваме константи референции и кога - rvalue references
Естествен въпрос, който можем да си зададем е кога бихме предпочели да подаваме константни референции и кога - rvalue referencse. Като насоки, можем да използваме следните точки:

Използваме константни референции, когато:
- искаме да си спестим копирането на големи обекти в паметта, които ще продължат да се ползват в програмата.
- не искаме да променяме обектите или искаме да запазим данните в тях;
- искаме да върнем като стойност на функция съществуващ обект, но не искаме той да бъде променян;

Използваме rvalue references, когато:
- искаме да си спестим копирането на големи временни обекти;
- искаме да "откраднем" стойността, сочена от референцията;
- не искаме да правим дълбоки копия на обектите, а само да "преместим" данните от един обект в друг, понеже вторият вече е ненужен.

Разбира се, този списък не е изчерпателен, но е добра насока, когато се чудим кой от двата варианта да използваме.

## Елизия на копирането
Когато определени условия бъдат спазени, създаването на обект от даден клас от друг обект (посредством копиране или преместване) може да бъде пропуснато. Това означава, че обектът няма да бъде копиран или преместен от един обект в друг, а директно ще бъде създаден във втория. Така се спестява извикаването на конструктора за копиране или преместване, дори те да съдържат странични ефекти. Тази оптимизация на компилатора се нарича елизия на копирането (copy elision). Условията тя да бъде приложена са сравнително сложни ([тук](https://en.cppreference.com/w/cpp/language/copy_elision) може да намерите подробно описани условията), затова ние ще разгледаме 2 по-често възникващи:

- когато създаваме обект при връщането на резултат от функция - в този случай се нарича оптимизация при върнатите стойности (return value optimization - RVO)
- когато инициализираме обект, подавайки в конструктора му друг временен обект от същия тип

Ето пример за тези два случая:

```c++
class A {
public:
  A (int x) : x(x) {}
  A (const A& other) : x(other.x) {
    std::cout << "copy constructor\n";
  }
  A (A&& other) noexcept : x(std::exchange(other.x, 0)) {
    std::cout << "move constructor\n";
  }

private:
  int x;
};

A foo() {
  return A(7);
}

int main() {
  A a(foo()); // nothing gets printed - copy elision
  A b(std::move(foo())); // move constructor - forcing the move constructor using std::move
  A c = A(5); // nothing gets printed - copy elision
  return 0;
}
```

## Задача 01 - Разширение на класове
За следните класове добавете и контруктор за преместване, и оператор за преместване:
- класа `Student` от седмица 03;
- класа `Sorted` от седмица 06;
- класа `LinkedList` от седмица 08;

## Задача 02 - Unique Pointer
В стандартната библиотека на C++ има няколко класа, които имат общото име `smart pointers`. Това са такива класове, които "обвиват" нормалните указатели и правят работата с тях доста по-лесна. Един такъв `smart pointer` е `std::unique_ptr`. Той представлява `RAII` контейнер за указателите, т.е. грижи се затова да няма споделяне на памет и за унищожаването на паметта, заделена от указателя. За да се гарантира първото, конструктора за копиране и операторът за присвояване са изтрити. Ако искаме да създадем нов `std::unique_ptr`, който съдържа същия указател, трябва да използваме конструктора за преместване или оператора за преместване, които ще "откраднат" указателя от първоначалния `std::unique_ptr`. Задачата ви е да имплементирате своя версия на този `smart pointer` като имате предвид горните особености. Освен това реализирайте и следните оператори:
- оператор* за достъп до обекта, сочен от указателя - направете константна и неконстантна версия;
- оператор-> за константен достъп до самия указател;
- други методи и оператори, които сметнете, че е добре да има.

## Задача 03 - File Handle
Напишете `RAII` контейнер, подобен на `unique pointer`, който се грижи за правилното управление на файлов поток. Помислете кои конструктори и оператори от `rule of 5` трябва да реализирате за този клас. Като допълнение, реализирайте и следните методи:
- write - записва символен низ във файла;
- read - прочита определен брой символи от файла;
- getline - прочита символи от файла до срещането на подаден разделител или до достигане на подадения брой символи;
- ignore - прочита и изхвърля символи до срещането на подаден разделител или до достигане на подадения брой символи;