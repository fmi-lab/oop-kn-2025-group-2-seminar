# Седмица 15 - Двоични файлове и изключения

## Побитови операции
Данните на нашите програми се пазят в паметта под формата на битове, а всички операции над тях, като например събиране на числа, модулно делене и т.н. са реализирани чрез булева алгебра над тези битове. Операторите в тази булева алгебра са познатите ни булеви операции - отрицание, логическо и, логическо или, xor и т.н. Когато тези операции се прилагат над битовата репрезентация на данните ги наричаме побитови операции. В повечето езици за програмиране, включително и C++, тези оператори са вградени и могат да се използват върху всички интегрални типове. Основната причина, по която бихме искали да ги използваме е, че те са в пъти по-бързи от всички останали операции, понеже те работят на най-ниското възможно ниво. Трябва обаче много да внимаваме с тяхната употреба, понеже те модифицират битовете на данните и понякога резултатите могат да бъдат по-различни от очакваните. В C++ побитовите операции включват:

- побитово отрицание `~` - обръща всички битове на операнда, като се взима в предвид [Two's complement](https://en.wikipedia.org/wiki/Two%27s_complement):

```c++
std::cout << ~7 << '\n'; // -> -8
```

- побитово и `&` - прилага логическо и поелементно върху битовете на операндите:

```c++
std::cout << (3 & 5) << '\n'; // -> 1
```

- побитово или `|` - прилага логическо или поелементно върху битовете на операндите:

```c++
std::cout << (3 | 5) << '\n'; // -> 7
```

- побитов xor `^` - прилага xor поелементно върху битовете на операндите:

```c++
std::cout << (3 ^ 5) << '\n'; // -> 6
```

- ляво отместване (left shift) - отмества битовете на операнда наляво като добавя 0 в дясната част:

```c++
std::cout << (3 << 3) << '\n'; 
```

- дясно отместване (right shift) - отмества битовете на операнда надясно като добавя 0 в лявата част:

```c++
std::cout << (35 >> 2) << '\n';
```

## Двоични файлове срещу текстови файлове
До сега разглеждахме файловете като потоци, но всъщност с тях можем да правим доста повече неща, от тези които можем да правим с обикновените потоци. Например, във файловите потоци се пазят 2 указателя - един за четене и един за писане. Всъщност тези указатели ни дават възможност за пряк достъп до данните във файла, но за целта трябва данните в него да са добре форматирани. При текстовите файлове имаме форматиран вход и изход, т.е. данните се записват във формат, удобен за четене от хора (UTF-8 например), но в неудобен формат за четене от програмите. В този случай ние не можем да достъпваме пряко обектите, записани във файла, понеже нямаме гаранция, че всички обекти ще имат равен размер. За сметка на това пък, последователния достъп е доста лесен, особено понеже имаме операторите за форматиран вход и изход - >> и <<. За да гарантираме, че обекти от един и същи тип, ще заемат един и същи размер при запис във файла, трябва този запис да бъде неформатиран - т.е. трябва данните да бъдат записани директно като байтове, а не като кодирани символи. Файлове, които съхраняват "сурови" последователности от байтове се наричат двоични файлове. Освен, че двоичните файлове предразполагат пряк достъп до данните в тях, четенето и писането от тях е доста по-ефективно спрямо тези при текстовите файлове.

## Запис и четене от двоични файлове
За да пишем и четем от двоичен файл на първо място, трябва да отворим файла в режим за работа с двоични файлове - това става като при отварянето на файла вдигнем флага `std::ios::binary`. За работа с отворения вече двоичен файл, не можем да използваме операторите >> и <<, понеже както стана дума по-горе, те служат само за форматиран вход и изход. За работа с неформатиран вход и изход, се използват функциите `write` и `read`. Те приемат указател към масив от тип `char` и брой знаци, които да бъдат записани/прочетени (`write` и `read` не спират при срещане на терминираща нула!). Но както знаем, размерът на `char` е точно 1 байт - т.е. ако успеем да "транслираме" нашите обекти до последователност от тип `char`, то ние ще успеем да ги запишем в двоичен формат. В C++ това се постига чрез оператора `reinterpret_cast`. Чрез него ние можем да преобразуваме указател от всякакъв тип до указател от всякакъв друг тип. Това става, като се запази последователността от битове на обекта, сочен от оригиналния указател, и само се промени тяхната интерпретация спрямо типа на новия указател. Това е най-опасният вид преобразуване на типове и трябва да го използваме, само когато сме абсолютно сигурни, че знаем какво правим. Нека разгледаме пример за писане и четене от двоичен файл:

```c++
struct Triangle {
  double a, b, c;
};

int main() {
  Triangle triangle = { .a = 3, .b = 4, .c = 5};
  std::fstream file("triangle.bin", std::ios::out | std::ios::binary);

  file.write(reinterpret_cast<const char*>(&triangle), sizeof(Triangle));
  file.close();

  file.open("triangle.bin", std::ios::in | std::ios::binary);

  Triangle input;
  file.read(reinterpret_cast<char*>(&input), sizeof(Triangle));
  file.close();

  std::cout << input.a << ' ' << input.b << ' ' << input.c << '\n'; // -> 3 4 5
  return 0;
}
```

## Пряк достъп в двоични файлове
След като вече видяхме как можем да пишем и четем от двоични файлове, можем най-накрая да видим как да достъпваме пряко данни, записани в двоичен формат. Ако знаем, че файлът ни се състои от данни от еднороден тип, то можем да се отместваме на равни интервали с размер равен на един обект от този тип, за да си гарантираме, че указателят ще бъде винаги в началото на обект от този тип. Ето пример, при който искаме да вземем петия триъгълник от файл, съдържащ само триъгълници в двоичен формат:

```c++
std::fstream file("triangles.bin", std::ios::in | std::ios::binary);

Triangle input;
file.seekg(4 * sizeof(Triangle));
file.read(reinterpret_cast<char*>(&input), sizeof(Triangle));
file.close();
```

## Особености при сериализация на динамично заделени данни
Едно от най-важните неща които засегнахме при работата с двоични файлове, е че искаме сериализираните обекти да имат еднакъв размер, за да можем лесно да извършваме пряк достъп до тях. Когато обаче имаме динамично заделени данни в обектите се срещаме с нов проблем - в обекта пазим само указател към тези данни, а размерът на самите данни може да варира. Ако сериализираме само указателя, ще бъде грешно, понеже адресът сочен от него е валиден само за текущата програма - след нейното приключване паметта, сочена от него, ще бъде освободена и при последвал достъп ще получим грешка при сегментацията. Решението в случая е да запазим първо размерът на динамично заделените данни и след това да сериализираме и тях. Така, при следващо четене от файла, ще знаем колко точно байта заема нашия обект, но тогава се сблъскваме със същия проблем, който имахме и при текстовите файлове - данните имат различен размер и прекият достъп вече не е толкова лесен. Има няколко начина, по които можем да се справим с този проблем:

- да пазим в отделен файл таблица с началните позиции на всеки обект във файла;
- да пазим динамично заделените данни в отделна секция от файла и на тяхно място в обектите да пазим указател към позициите на тези данни;
- към всеки обект да запишем и заглавна част (header), която носи допълнителна информация за обекта, като например размера на данните в него и др.

## Механизмът на изключенията
Чрез изключенията можем да обработваме грешки по време на изпълнение или други необичайни ситуации по структуриран начин. Изключения можем да създаваме (или още "хвърляме") чрез оператора `throw` последван от произволна стойност (може да бъде оставен и празен). При настъпване на изключение, от програмния стек започват да се премахват извикванията, през които се е минало, за да настъпи изключението, като изключението и неговата стойност се предават нагоре по стека. С други думи, извикванията започват да се терминират насилствено. В даден момент, това терминиране може да бъде предотвратено, ако се използва операторът `try...catch`. Той се състои съответно от `try` блок и няколко `catch` блока - ако в `try` блока настъпи изключение, текущото извикване няма да бъде терминирано, а ще се премине към `catch` блоковете - всеки от тях описва какъв тип стойност на изключенията очаква и при съвпадение ще се изпълни съответния `catch` блок. Ако обаче изключението не съвпада с нито един тип в `catch` блоковете, то изключението няма да бъде обработено и ще продължи да се предава нагоре по стека. Ако все пак искаме да обработим всички изключения, независимо от типа им, можем да използваме `catch(...)`. Ето пример за обработка на изключения:

```c++
int f(int a) {
  if (a == 0) {
    throw -1;
  }

  return 7 / a;
}

int main() {
  int a;
  std::cin >> a;
  
  try {
     std::cout << f(a) << '\n';
  } catch (int e) {
    std::cout << "Exception: " << e << '\n';
  } catch (...) {
    std::cout << "Exception\n";
  }

  std::cout << "end\n";
  return 0;
}
```

## Видове изключения
Не е добра практика да се хвърлят изключения с произволни стойности. Вместо това, по-добрият вариант е да се хвърлят изключения от тип `std::exception`. Въпреки, че е по-добър вариант от това да хвърляме изключения с произволни стойности, `std::exception` пак не описва подробно какво се е случило. Понякога обаче се налага да имаме различна логика за обработка на изключенията в зависимост от това, какво ги е предизвикало. В тези случаи е по-добре да използваме типовете изключения, съдържащи се в заглавния файл `<stdexcept>`. Той съдържа изключения като `std::runtime_error, std::invalid_argument, std::out_of_range` и други. Те всъщност са наследници на `std::exception`, които приемат в конструктора си съобщение, описващо причината за тяхното възникване, и вече носят семантиката на изключението в типа си. Добра практика е, когато имаме изключения, свързани с домейна на нашата програма, да създаваме наши собствени типове изключения като наследим `std::exception`. Това можем да направим по следните начини:

```c++
class NegativeNumberException : public std::exception {
public:
  NegativeNumberException(const char* message) 
  : message(message) {}

  const char* what() const noexcept final {
    return message;
  }

private:
  const char* message;
};

class ZeroNumberException : public std::invalid_argument {
public:
  ZeroNumberException(const char* message) 
    : std::invalid_argument(message) {}
};

```

Сега вече примерът от по-горе би изглеждал така:

```c++
int f(int a) {
  if (a == 0) {
    throw ZeroNumberException("Argument can not be 0");
  }

  if (a < 0) {
    throw NegativeNumberException("Provided argument is negative");
  }

  return 7 / a;
}

int main() {
  int a;
  std::cin >> a;
  
  try {
     std::cout << f(a) << '\n';
  } catch (const NegativeNumberException& e) {
    std::cout << "NegativeNumberException: " << e.what() << '\n';
  } catch (const ZeroNumberException& e) {
    std::cout << "ZeroNumberException: " << e.what() << '\n';
  } catch (const std::exception& e) {
    std::cout << "Exception: " << e.what() << '\n';
  }

  std::cout << "end\n";
  return 0;
}
```

## Гаранции за изключенията
Когато в една програма могат да настъпят изключения, един от основните въпроси, които възникват са, след обработване на изключенията, какво е състоянието на програмата. Например, може ли да се продължи от мястото на хвърляне на изключението, може ли въобще да се продължи от някъде или цялата програма приключва. Отговорите на тези въпроси се определят от гаранциите за изключения (exception guarantees) - всяка функция гарантира по какъв начин ще обработи изключенията, които възникват в нея. Има 4 вида гаранции:

- гаранция за невъзможност на настъпване на изключение (nothrow exception guarantee) - гарантира, че във функцията няма как да настъпи изключение и може да се декларира чрез `noexcept`. Това е единствената гаранция, която може да се декларира изрично в кода;
- силна гаранция за изключения (strong exception guarantee) - ако във функцията настъпи изключение, то състоянието на програмата ще се възстанови до последното състояние преди извикването на функцията. Добра практика е да се стремим да имаме силна гаранция колкото е възможно повече;
- основна гаранция за изключения (basic exception guarantee) - ако във функцията настъпи изключение, то състоянието на програмата ще остане валидно след обработката му, но не се гарантира какво точно ще бъде то;
- без гаранция за изключения (no exception guarantee) - ако във функцията настъпи изключение, то програмата няма да бъде във валидно състояние. Трябва да се опитваме да избягваме тези случаи колкото е възможно повече.

## Задача 01 - Побитови операции
Да се реализират следните функции чрез употребата на побитови операции:
- void swap(int a, int b) - разменя стойностите на 2 числа;
- bool even(int a) - проверява дали подаденото число е четно;
- int change_sign(int a) - връща подаденото число с обратен знак;
- size_t ones(int a) - връща колко единици има в двоичния запис на подаденото число;
- int sum(int a, int b) - връща сбора на двете подадени числа;
- RGB extractColors(unsigned a) - по подадено шестнайсетично число от 0x000000 до 0xFFFFFF връща наредена тройка от кода на червения, зеления и синия цвят.

## Задача 02 - Интерфейси за сериализиране и десериализиране
Да се реализира интерфейс `BinaryCodec`, който съдържа следните методи:
- void serialize(std::ofstream& file) - записва обекта в двоичен файл;
- void deserialize(std::ifstream& file) - чете обект от двоичен файл;

Да се реализира интерфейс `RandomAccessBinaryCodec`, който наследява `BinaryCodec` и съдържа следните методи:
- void serialize_at(std::ofstream& file, std::size_t pos) - записва обекта в двоичен файл на конкретна позиция;
- void deserialize_at(std::ifstream& file, std::size_t pos) - чете обект от двоичен файл от конкретна позиция.

## Задача 03 - Библиотека
Да се реализира клас `Book`, който представлява книга, която има име (до 100 символа), автор (до 50 символа) и уникален номер (положително цяло число). Класът да реализира интерфейса `RandomAccessBinaryCodec`.

Да се реализира клас `Library`, който представлява библиотека, която има име с произволна дължина и списък от книги. Класът да реализира интерфейса `BinaryCodec`. Освен това да се реализират следните методи:
- void add(const Book& book) - добавя книга към библиотеката;
- std::size_t get_list_size() const - връща размера на списъка с книгите;
- const std::string& get_name() const - връща името на библиотеката;

Да се реализира клас `LibraryHandler`, който съдържа библиотека и двоичен файл с информация за библиотеката. Да се реализират следните методи:
- LibraryHandler() - конструктор без параметри;
- LibraryHandler(const std::string& filename) - конструктор, който получава името на файла с информацията и зарежда библиотеката от този файл;
- void load(std::string& filename) - зарежда библиотеката от файл с подаденото име;
- void save() - запазва промените по библиотеката във файла;
- void add(const Book& book) - добавя книга към библиотеката;
- void replace(std::size_t index, const Book& book) - променя книгата на позиция `index` в списъка на `book`. Промяната да се отрази във файла с информацията за библиотеката, без да се сериализира цялата библиотека.

## Задача 04 - Обработка на изключения
Реализирайте ваше собствено изключение, което да сигнализира за липса на файл при опит за неговото отваряне. Като използвате създаденото от вас изключение, погрижете се за правилното обработване на грешки в предните задачи. При нужда, може да използвате и изключенията от стандартната библиотека. Целете се да постигнете strong exception guarantee. Експлицитно обявете кои функции не трябва да хвърлят изключение.